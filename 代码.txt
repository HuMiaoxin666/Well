function showcurves(click_arr) {
    wtdatas = [];
    
    wbdatas = [];

    var attrnames=["COND","SP","AC","ML1","ML2"];
    var attrno=2;
    var attrn=attrnames[attrno];

    for(var n=0;n<click_arr.length;n++)
    {
      var filename="well_curves/"+click_arr[n].ID+".las";

      readtext(filename);
      var totalstring=wtdatas[n];
      var strings=totalstring.split("\n");

      var curved=[]; //存储1000-1500米之间的数据
      var cdkey=[]; //存储属性
      
      var istest=false;
      //处理文本数据
      for(var i=0;i<strings.length;i++)
      {
        var temps=[];
        var substrings=strings[i].split(/\t|\s/g);

        for(var j=0;j<substrings.length;j++)
          if(substrings[j].replace(/(^s*)|(s*$)/g, "").length !=0 ) 
            temps.push(substrings[j]); 

        if(istest)
        {
          var testv=parseFloat(temps[0]);
          if(testv>= 600.0 && testv<=1500.0)
          {
            var tempcurved={};
            for(var k=0;k<temps.length;k++)
              tempcurved[ cdkey[k] ]= parseFloat(temps[k]);
            curved.push(tempcurved);
          }
        } else {
          if(temps[0]=="~A")
          {
            istest=true;

            for(var k=1;k<temps.length;k++)
              cdkey.push(temps[k]);
          }
        }
      }
      console.log('curved: ', curved);
      console.log('cdkey: ', cdkey);
      ////////////绘制显示不同属性的曲线///////////////////////////////////////////////////////////////////////////////////
      ///////////////先绘制测试参数指定的属性//////////////////////////////////////////////////////////////////////////////

      var fcd=curved.filter(function(cd){return (cd.DEPT>=TopH)&&(cd.DEPT<=BotH)&&(cd[attrn]> -1000.0)&&(cd[attrn]<1000.0) });

      //处理异常数据//////////////////////////////////////////////////
      if(attrno==2){
        var fcdtemp=curved.filter(function(cd){ return (cd.DEPT>=TopH)&&(cd.DEPT<=BotH)&&(cd[attrn]>50.0)&&(cd[attrn]<1000.0); });
        var fcdmean=d3.mean(fcdtemp, function(cd){ return cd[attrn]});

        for(var i=0;i<fcd.length;i++)
          if(fcd[i][attrn] < 50.0)
            fcd[i][attrn]=fcdmean;
      }

      //保存原始曲线数据，用于绘制细节对比
      var curvedata=fcd;
      console.log('curved: ', curved);
//AC的最大最小值
      var mind=d3.min(fcd, function(d){ return d[attrn]});
      var maxd=d3.max(fcd, function(d){ return d[attrn]});

      //归一化//////////////////////////////////////////////
      console.log(fcd);
      for(var i=0;i<fcd.length;i++)
      {
        fcd[i][attrn]=gmaxv*(fcd[i][attrn]-mind)/(maxd-mind);

        fcd[i].lmax=0;
        fcd[i].lmin=0;
      }

      //标记极大值、极小值
      for(var i=1;i<fcd.length-1;i++)
      {
        if(fcd[i][attrn]-fcd[i-1][attrn]>0.0 && fcd[i+1][attrn]-fcd[i][attrn]<0.0) fcd[i].lmax=1;
        if(fcd[i][attrn]-fcd[i-1][attrn]<0.0 && fcd[i+1][attrn]-fcd[i][attrn]>0.0) fcd[i].lmin=1;
      }

      var XScale = d3.scaleLinear().domain([gminv, gmaxv]).range([0, well_width]);

      var sx=startx+(well_width+interval)*n;

      var line = d3.line()
            .x(function(d) { return sx+XScale(d[attrn]); })
            .y(function(d) { return starty+FlagScale(d.DEPT); });

      //////////////////1.测井曲线数据预处理//////////////////////////////////////////////////////////////////
      /////////////1.1异常值校正、缺失值插值/////////////////////////////////////////////////////////////////////////////

      /////////////1.2.中值滤波////////////////////////////////////////////////////////////////////////////////////////
      var midvf_N=10;  //中值滤波前后各取值的数量

      for(var ti=0;ti<fcd.length;ti++)
      {
        var tempN=midvf_N;
        if(ti<midvf_N) tempN=ti;
        if(ti>fcd.length-1-midvf_N) tempN=fcd.length-ti-1;

        var midvs=[];//存放前后的取值
        for(var tj=ti-tempN; tj< ti+tempN+1; tj++)
          midvs.push(fcd[tj][attrn]);
        //取中值//////////////////////////
        fcd[ti]["MV_"+attrn]=d3.median(midvs);
      }

      //绘制中值曲线//////////////////////
      var linem = d3.line()
            .x(function(d) { return sx+XScale(d["MV_"+attrn]); })
            .y(function(d) { return starty+FlagScale(d.DEPT); });

      ////////////////1.3.根据中值计算活度函数及绘制///////////////////////////////////////////////////////////////////////
      var act_N=15;  //活度计算前后各取值的数量

      fcd[0]["AV_"+attrn]=0.0;
      fcd[fcd.length-1]["AV_"+attrn]=0.0;

      var isiter=false;
      var Rd=0.0,Td=0.0;

      for(var ti=1;ti<fcd.length-1;ti++)
      {
        var tempN=act_N;

        if(ti < act_N)
        {
          tempN=ti;
          var actvs=[];

          for(var tj=ti-tempN; tj< ti+tempN+1; tj++)
            actvs.push(fcd[tj]["MV_"+attrn]);

          fcd[ti]["AV_"+attrn]=d3.variance(actvs);

        } else if(ti>=act_N && ti<=fcd.length-1-act_N) {
          if(isiter)
          {
            Rd=Rd-(fcd[ti-tempN-1]["MV_"+attrn]*fcd[ti-tempN-1]["MV_"+attrn])+(fcd[ti+tempN]["MV_"+attrn]*fcd[ti+tempN]["MV_"+attrn]);
            Td=Td-fcd[ti-tempN-1]["MV_"+attrn] + fcd[ti+tempN]["MV_"+attrn];

            fcd[ti]["AV_"+attrn]=Rd-Td*Td/(2*tempN+1);
          } else {
            isiter=true;
            for(var tj=ti-tempN; tj< ti+tempN+1; tj++)
            {
              Rd+=(fcd[tj]["MV_"+attrn]*fcd[tj]["MV_"+attrn]);
              Td+=fcd[tj]["MV_"+attrn];
            }
            fcd[ti]["AV_"+attrn]=Rd-Td*Td/(2*tempN+1);
          }
        } else {
          tempN=fcd.length-ti-1;
          var actvs=[];

          for(var tj=ti-tempN; tj< ti+tempN+1; tj++)
            actvs.push(fcd[tj]["MV_"+attrn]);

          fcd[ti]["AV_"+attrn]=d3.variance(actvs);
        }
      }

      //统计活度值范围
      var mina=d3.min(fcd, function(d){ return d["AV_"+attrn]});
      var maxa=d3.max(fcd, function(d){ return d["AV_"+attrn]});

      var AXScale = d3.scaleLinear().domain([mina, maxa]).range([0, well_width]);

      //绘制活度函数曲线//////////////////////
      var linea = d3.line()
            .x(function(d) { return sx+AXScale(d["AV_"+attrn]); })
            .y(function(d) { return starty+FlagScale(d.DEPT); });

      ////////////////1.4.阈值检验活度极值///////////////////////////////////////////////////////////////////////////////
      var av_threshold=maxa*0.05;
      /////计算活度值差分/////////////////
      var diffs=[];
      for(var ti=1;ti<fcd.length;ti++) diffs.push(fcd[ti]["AV_"+attrn] - fcd[ti-1]["AV_"+attrn]);

      var borders=[];  //存放符合阈值的活度深度索引
    	borders.push(1);

      for(var ti=0;ti<diffs.length-1;ti++)
        if(diffs[ti]>0.0 && diffs[ti+1]<0.0 && fcd[ti+1]["AV_"+attrn]>=av_threshold)
          borders.push(ti+1);
      borders.push(diffs.length-2)

      ////////////1.5.层均值检验进行薄层合并/////////////////////////////////////////////////////////////////////////////////

   		////////////1.6.井层数据设计//////////////////////////////////////////////////////////////////////////////////////////
      var wbdata={};
      wbdata.idn=click_arr[n].ID;
      wbdata.bdata=[];
      wbdata.cdata=curvedata;

      //标记//
      for(var k=1;k<borders.length;k++)
      {
        var indext=borders[k-1], indexb=borders[k];
        var tempbd={};

        tempbd.indext = indext;
        tempbd.indexb = indexb;

        tempbd.th=fcd[indext].DEPT;   //层顶深度
        tempbd.bh=fcd[indexb].DEPT;   //层底深度
        tempbd.dh=tempbd.bh-tempbd.th;   //层的厚度

        var bvs=[],rmvs=[];

        for(var tm=indext;tm<=indexb;tm++)
        {
          bvs.push(fcd[tm][attrn]);
          rmvs.push(fcd[tm][attrn]*(tm-indext+1));
        }

        //存放原始数据
        tempbd.bvs = bvs;

        tempbd.fv=d3.variance(bvs);   //方差
        tempbd.mv=d3.mean(bvs);   //均值
        tempbd.rm=d3.sum(rmvs)/((indexb-indext+1)*d3.sum(bvs));  //相对重心

        tempbd.maxv=d3.max(bvs);  //最大值
        tempbd.minv=d3.min(bvs);  //最小值

        //新添加属性:最大最小值之差，上下陡度，极大极小值及相对位置/////////////////////////////
        tempbd.dtv=tempbd.maxv-tempbd.minv; //最大值最小值之差

        tempbd.topk=fcd[indext+1][attrn]-fcd[indext-1][attrn]; //上陡度，定义为边界处的斜率
        tempbd.botk=fcd[indexb+1][attrn]-fcd[indexb-1][attrn]; //下陡度

        var lmaxvs=[],lminvs=[];
        for(var tm=indext;tm<=indexb;tm++)
        {
          if(fcd[tm].lmax==1) lmaxvs.push([fcd[tm][attrn],tm]);
          if(fcd[tm].lmin==1) lminvs.push([fcd[tm][attrn],tm]);
        }

        tempbd.lmaxv=-1,tempbd.lminv=-1,tempbd.lmaxp=-1,tempbd.lminp=-1;

        if(lmaxvs.length>0)
        {
          //排序，找出最大的极大值
          function compareLmaxv(a, b) {return b[0]-a[0];}

          lmaxvs.sort(compareLmaxv);

          tempbd.lmaxv=lmaxvs[0][0];
          tempbd.lmaxp=(lmaxvs[0][1]-indext)/(indexb-indext);
        }

        if(lminvs.length>0)
        {
          //排序，找出最小的极小值
          function compareLminv(a, b) { return a[0]-b[0]; }

          lminvs.sort(compareLminv);

          tempbd.lminv=lminvs[0][0];
          tempbd.lminp=(lminvs[0][1]-indext)/(indexb-indext);
        }
        wbdata.bdata.push(tempbd);
      }
      wbdatas.push(wbdata);
    }
    console.log(wbdatas)
  }
